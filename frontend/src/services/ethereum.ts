import { ethers, BrowserProvider, Contract, JsonRpcProvider } from 'ethers';

// Contract ABIs (simplified - will be generated by Hardhat)
const LOYALTY_PLATFORM_ABI = [
  "function loyaltyToken() view returns (address)",
  "function protocolTreasury() view returns (address)",
  "function baseMintFee() view returns (uint256)",
  "function feeRatePerThousand() view returns (uint256)",
  "function solToPointsRatio() view returns (uint256)",
  "function isActive() view returns (bool)",
  "function merchantCount() view returns (uint256)",
  "function totalFeesCollected() view returns (uint256)",
  "function merchants(address) view returns (bool isAuthorized, uint256 mintAllowance, uint256 totalMinted, uint256 totalRedeemed, uint256 totalFeesPaid, uint256 registeredAt)",
  "function registerMerchant(address merchant, uint256 mintAllowance)",
  "function revokeMerchant(address merchant)",
  "function mintPoints(address consumer, uint256 amount, string purchaseReference) payable",
  "function purchaseProductWithETH(address merchant, bytes32 productIdHash, uint256 loyaltyPointsReward) payable",
  "function redeemPoints(address merchant, uint256 amount, string rewardId)",
  "function purchaseProductWithPoints(address merchant, bytes32 productIdHash, uint256 pointsAmount)",
  "function depositETH() payable",
  "function calculateMintFee(uint256 amount) view returns (uint256)",
  "function getMerchantInfo(address merchant) view returns (tuple(bool isAuthorized, uint256 mintAllowance, uint256 totalMinted, uint256 totalRedeemed, uint256 totalFeesPaid, uint256 registeredAt))",
  "function getPlatformStats() view returns (address tokenAddress, uint256 totalSupply, uint256 maxSupply, uint256 merchantCount, uint256 totalFeesCollected, bool isActive)",
  "event MerchantRegistered(address indexed merchant, uint256 mintAllowance)",
  "event PointsMinted(address indexed consumer, address indexed merchant, uint256 amount, string reference)",
  "event ProductPurchased(address indexed customer, address indexed merchant, bytes32 productIdHash, uint256 price, uint256 points)"
];

const LOYALTY_TOKEN_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function maxSupply() view returns (uint256)",
  "function balanceOf(address account) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function transferFrom(address from, address to, uint256 amount) returns (bool)",
  "event Transfer(address indexed from, address indexed to, uint256 value)"
];

// Get contract addresses from environment
const PLATFORM_ADDRESS = import.meta.env.VITE_PLATFORM_ADDRESS || '';
const RPC_URL = import.meta.env.VITE_RPC_URL || 'http://localhost:8545';
const CHAIN_ID = parseInt(import.meta.env.VITE_CHAIN_ID || '1337');

/**
 * Get Ethereum provider from MetaMask or other wallet
 */
export async function getProvider(): Promise<BrowserProvider | null> {
  if (typeof window.ethereum !== 'undefined') {
    return new BrowserProvider(window.ethereum);
  }
  return null;
}

/**
 * Get read-only provider for queries
 */
export function getReadOnlyProvider(): JsonRpcProvider {
  return new JsonRpcProvider(RPC_URL);
}

/**
 * Get the platform contract instance
 */
export async function getPlatformContract(signerOrProvider?: any): Promise<Contract> {
  if (!PLATFORM_ADDRESS) {
    throw new Error('Platform contract address not configured');
  }
  
  const providerToUse = signerOrProvider || getReadOnlyProvider();
  return new Contract(PLATFORM_ADDRESS, LOYALTY_PLATFORM_ABI, providerToUse);
}

/**
 * Get the loyalty token contract instance
 */
export async function getTokenContract(signerOrProvider?: any): Promise<Contract> {
  const platform = await getPlatformContract(signerOrProvider);
  const tokenAddress = await platform.loyaltyToken();
  
  const providerToUse = signerOrProvider || getReadOnlyProvider();
  return new Contract(tokenAddress, LOYALTY_TOKEN_ABI, providerToUse);
}

/**
 * Connect wallet and request account access
 */
export async function connectWallet(): Promise<string | null> {
  try {
    if (typeof window.ethereum === 'undefined') {
      throw new Error('MetaMask is not installed');
    }

    const provider = new BrowserProvider(window.ethereum);
    const accounts = await provider.send('eth_requestAccounts', []);
    
    // Check if on correct network
    const network = await provider.getNetwork();
    if (Number(network.chainId) !== CHAIN_ID) {
      await switchNetwork(CHAIN_ID);
    }
    
    return accounts[0];
  } catch (error) {
    console.error('Error connecting wallet:', error);
    return null;
  }
}

/**
 * Switch to the correct network
 */
export async function switchNetwork(chainId: number): Promise<void> {
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: `0x${chainId.toString(16)}` }],
    });
  } catch (switchError: any) {
    // This error code indicates that the chain has not been added to MetaMask
    if (switchError.code === 4902) {
      const networkConfig = getNetworkConfig(chainId);
      await window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [networkConfig],
      });
    } else {
      throw switchError;
    }
  }
}

/**
 * Get network configuration for adding to MetaMask
 */
function getNetworkConfig(chainId: number) {
  const configs: Record<number, any> = {
    1337: {
      chainId: '0x539',
      chainName: 'Localhost 8545',
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      rpcUrls: ['http://localhost:8545'],
    },
    11155111: {
      chainId: '0xaa36a7',
      chainName: 'Sepolia Testnet',
      nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
      rpcUrls: ['https://rpc.sepolia.org'],
      blockExplorerUrls: ['https://sepolia.etherscan.io'],
    },
    1: {
      chainId: '0x1',
      chainName: 'Ethereum Mainnet',
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      rpcUrls: ['https://eth.llamarpc.com'],
      blockExplorerUrls: ['https://etherscan.io'],
    },
  };
  
  return configs[chainId] || configs[1337];
}

/**
 * Get loyalty token balance for an address
 */
export async function getBalance(address: string): Promise<string> {
  try {
    const token = await getTokenContract();
    const balance = await token.balanceOf(address);
    return ethers.formatEther(balance);
  } catch (error) {
    console.error('Error getting balance:', error);
    return '0';
  }
}

/**
 * Check if platform is initialized
 */
export async function isPlatformInitialized(): Promise<boolean> {
  try {
    const platform = await getPlatformContract();
    const isActive = await platform.isActive();
    return isActive;
  } catch (error) {
    return false;
  }
}

/**
 * Check if a merchant is authorized
 */
export async function isMerchantAuthorized(merchantAddress: string): Promise<boolean> {
  try {
    const platform = await getPlatformContract();
    const merchantInfo = await platform.getMerchantInfo(merchantAddress);
    return merchantInfo.isAuthorized;
  } catch (error) {
    console.error('Error checking merchant authorization:', error);
    return false;
  }
}

/**
 * Get merchant information
 */
export async function getMerchantInfo(merchantAddress: string) {
  const platform = await getPlatformContract();
  const info = await platform.getMerchantInfo(merchantAddress);
  return {
    isAuthorized: info.isAuthorized,
    mintAllowance: ethers.formatEther(info.mintAllowance),
    totalMinted: ethers.formatEther(info.totalMinted),
    totalRedeemed: ethers.formatEther(info.totalRedeemed),
    totalFeesPaid: ethers.formatEther(info.totalFeesPaid),
    registeredAt: Number(info.registeredAt),
  };
}

/**
 * Get platform statistics
 */
export async function getPlatformStats() {
  const platform = await getPlatformContract();
  const stats = await platform.getPlatformStats();
  return {
    tokenAddress: stats.tokenAddress,
    totalSupply: ethers.formatEther(stats.totalSupply),
    maxSupply: ethers.formatEther(stats.maxSupply),
    merchantCount: Number(stats.merchantCount),
    totalFeesCollected: ethers.formatEther(stats.totalFeesCollected),
    isActive: stats.isActive,
  };
}

/**
 * Calculate mint fee for a given amount
 */
export async function calculateMintFee(amount: string): Promise<string> {
  const platform = await getPlatformContract();
  const amountWei = ethers.parseEther(amount);
  const fee = await platform.calculateMintFee(amountWei);
  return ethers.formatEther(fee);
}

/**
 * Hash product ID for on-chain storage
 */
export function hashProductId(productId: string): string {
  return ethers.keccak256(ethers.toUtf8Bytes(productId));
}

/**
 * Shorten an Ethereum address for display
 */
export function shortenAddress(address: string, chars = 4): string {
  if (!address) return '';
  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`;
}

/**
 * Get block explorer URL
 */
export function getExplorerUrl(
  addressOrTxHash: string,
  type: 'address' | 'tx' = 'address',
  chainId: number = CHAIN_ID
): string {
  const explorers: Record<number, string> = {
    1: 'https://etherscan.io',
    11155111: 'https://sepolia.etherscan.io',
    1337: '', // Localhost has no explorer
  };
  
  const baseUrl = explorers[chainId] || explorers[1];
  if (!baseUrl) return '';
  
  const path = type === 'tx' ? 'tx' : 'address';
  return `${baseUrl}/${path}/${addressOrTxHash}`;
}

/**
 * Format ether amount for display
 */
export function formatEther(value: bigint | string): string {
  return ethers.formatEther(value);
}

/**
 * Parse ether amount from user input
 */
export function parseEther(value: string): bigint {
  return ethers.parseEther(value);
}

export { PLATFORM_ADDRESS, RPC_URL, CHAIN_ID };
